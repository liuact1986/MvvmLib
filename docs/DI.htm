<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>MvvmLib.IoC - MvvmLib Documentation</title>
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="css/theme.css" type="text/css" />
    <link rel="stylesheet" href="css/theme_colors.css" type="text/css" />
    <link rel="stylesheet" href="css/styles/vs.css">
    <link rel="stylesheet" href="css/font-awesome.4.5.0.min.css">
</head>
<body role="document">
    <div class="grid-for-nav">
        <nav data-toggle="nav-shift" class="nav-side stickynav">
            <div class="side-nav-search">
                <a href="index.htm"><i class="fa fa-home"></i> MvvmLib Documentation</a>
                <div role="search">
                    <form id="search-form" class="form" action="Docnet_search.htm" method="get">
                        <input type="text" name="q" placeholder="Search docs" />
                    </form>
                </div>
            </div>
            <div class="menu menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
<ul>
<li class="tocentry"><a href="index.htm">Home</a>
</li>

<li class="tocentry"><a href="Mvvm.htm">MvvmLib.Core</a>
</li>
<li class="tocentry current"><a class="current" href="DI.htm">MvvmLib.IoC</a>
<ul class="currentrelative">
<li class="tocentry"><a href="#registering">Registering</a></li>

<li class="tocentry"><a href="#getinstance">GetInstance</a></li>

<li class="tocentry"><a href="#autodiscovery">AutoDiscovery</a></li>

<li class="tocentry"><a href="#nonpublicconstructors-and-nonpublicproperties">NonPublicConstructors and NonPublicProperties</a></li>

<li class="tocentry"><a href="#preferredconstructorattribute">PreferredConstructorAttribute</a></li>

<li class="tocentry"><a href="#delegatefactorytype">DelegateFactoryType</a></li>

<li class="tocentry"><a href="#events">Events</a></li>



</ul>
<li class="tocentry"><a href="Navigation.htm">MvvmLib.Wpf</a>
</li>
<li class="tocentry"><a href="Navigation_Uwp.htm">MvvmLib.Windows</a>
</li>
<li class="tocentry"><a href="Navigation_XF.htm">MvvmLib.XF</a>
</li>
<li class="tocentry"><a href="Adaptive.htm">MvvmLib.Adaptive.Wpf</a>
</li>
<li class="tocentry"><a href="Adaptive_Uwp.htm">MvvmLib.Adaptive.Windows</a>
</li>
<li class="tocentry"><a href="LICENSE.htm">LICENSE</a>
</li>
</ul>
				<div class="toc-footer">
					<span class="text-small">
						<hr/>
						<a href="https://github.com/FransBouma/DocNet" target="_blank">Made with <i class="fa fa-github"></i> DocNet</a>
					</span>
				</div>	
			</div>
            &nbsp;
        </nav>
        <section data-toggle="nav-shift" class="nav-content-wrap">
            <nav class="nav-top" role="navigation" aria-label="top navigation">
                <i data-toggle="nav-top" class="fa fa-bars"></i>
                <a href="index.htm">MvvmLib Documentation</a>
            </nav>
            <div class="nav-content">
                <div role="navigation" aria-label="breadcrumbs navigation">
                    <div class="breadcrumbs">
<ul><li><a href="index.htm">Home</a></li> / <li><a href="DI.htm">MvvmLib.IoC</a></li></ul>
					
                    </div>
                    <hr />
                </div>
                <div role="main">
                    <div class="section">
<h1 id="di-dependency-injection-with-injector">DI (Dependency Injection) with Injector<a class="headerlink" href="#di-dependency-injection-with-injector" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h1>
<blockquote>
<p>The injector allows to <strong>resolve all types and types for implemented interfaces automatically</strong> (views, view models, services) </p>
</blockquote>
<ul>
<li>Allows to <strong>register</strong> and <strong>resolve</strong> Type, Singleton, Instance, factory, values</li>
<li><strong>Auto discover</strong> types and types for interfaces not registered</li>
<li><strong>Inject</strong> properties and manage circular references</li>
<li>Attributes: <strong>PreferredConstructor</strong>, <strong>PreferredImplementation</strong> (for interfaces), <strong>Dependency</strong> (for properties) </li>
</ul>
<p><strong>Require to be registered :</strong></p>
<ul>
<li><strong>Singletons</strong></li>
<li>Use the <strong>PreferredImplementation attribute</strong> with many implementation of interfaces.</li>
</ul>
<p>Namespace: required for extensions methods</p>
<pre><code class="cs">using MvvmLib.Ioc;
</code></pre>

<p>Inject the service (recommanded)</p>
<pre><code class="cs">public class MyViewModel
{
    public MyViewModel(IInjector injector)
    {

    }
}
</code></pre>

<h2 id="registering">Registering<a class="headerlink" href="#registering" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h2>
<h3 id="constructor-injection">Constructor Injection<a class="headerlink" href="#constructor-injection" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h3>
<p>Types</p>
<pre><code class="cs">injector.RegisterType&lt;Item&gt;();
injector.RegisterType&lt;IMyService, MyService&gt;();
// with key
injector.RegisterType&lt;Item&gt;(&quot;my key&quot;);

// with value container (for value types, nullables, Uri, enumerables)...
injector.RegisterType&lt;Item&gt;().WithValueContainer(new ValueContainer { { &quot;myString&quot;, &quot;my value&quot; } });
</code></pre>

<p>Singleton</p>
<pre><code class="cs">injector.RegisterSingleton&lt;Item&gt;();
// with key
injector.RegisterSingleton&lt;Item&gt;(&quot;my key&quot;);
</code></pre>

<p>Instance</p>
<pre><code class="cs">injector.RegisterInstance&lt;Item&gt;(new Item());
// with key
injector.RegisterInstance&lt;Item&gt;(&quot;my key&quot;, new Item());
</code></pre>

<p>Factory</p>
<pre><code class="cs">injector.RegisterFactory&lt;Item&gt;(() =&gt; new Item());
// with key
injector.RegisterFactory&lt;Item&gt;(&quot;my key&quot;, () =&gt; new Item());
</code></pre>

<p>Func</p>
<pre><code class="cs">public class WithFunc
{
    public Item MyItem { get; set; }

    public WithFunc(Func&lt;Item&gt; myFunc)
    {
        MyItem = myFunc(); 
    }
}
</code></pre>

<pre><code class="cs">injector.RegisterInstance&lt;Item&gt;(new Item { MyString = &quot;My value&quot; });
injector.RegisterType&lt;WithFunc&gt;();

var instance = service.GetInstance&lt;WithFunc&gt;(); 
</code></pre>

<p>The injector resolves not registered types for <strong>interfaces</strong>. For many implementations use the <strong>PreferredImplementationAttribute</strong> Example:</p>
<pre><code class="cs">public interface IMyService
{ }

public class MyService1 : IMyService
{ }

[PreferredImplementation]
public class MyService2 : IMyService
{ }

public class MyService3 : IMyService
{ }
</code></pre>

<h3 id="registering-type-with-interfaces">Registering Type with interfaces<a class="headerlink" href="#registering-type-with-interfaces" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h3>
<pre><code class="cs">public interface ILookupDataServiceType1 { }

public interface ILookupDataServiceType2 { }

public interface ILookupDataServiceType3 { }

public class LookupDataService : ILookupDataServiceType1, ILookupDataServiceType2, ILookupDataServiceType3 
{ }
</code></pre>

<pre><code class="cs">injector.RegisterTypeWithInterfaces&lt;LookupDataService&gt;();
</code></pre>

<p>Avoid to do:</p>
<pre><code class="cs">injector.RegisterTypeWithInterfaces&lt;ILookupDataServiceType1, LookupDataService&gt;();
injector.RegisterTypeWithInterfaces&lt;ILookupDataServiceType2, LookupDataService&gt;();
injector.RegisterTypeWithInterfaces&lt;ILookupDataServiceType3, LookupDataService&gt;();
</code></pre>

<p>Set a registration as singleton</p>
<pre><code class="cs">var registrationOptionsContainer = injector.RegisterTypeWithInterfaces&lt;LookupDataService&gt;();
var registrationOptions2 = container[typeof(ILookupDataServiceType2)];
registrationOptions2.AsSingleton();
</code></pre>

<h3 id="registering-singleton-with-interfaces">Registering Singleton with interfaces<a class="headerlink" href="#registering-singleton-with-interfaces" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h3>
<p>Allows to get the same instance for all &quot;services&quot;.</p>
<pre><code class="cs">injector.RegisterSingletonWithInterfaces&lt;LookupDataService&gt;();
</code></pre>

<p>Set a registration as multi instances</p>
<pre><code class="cs">var registrationOptionsContainer = injector.RegisterSingletonWithInterfaces&lt;LookupDataService&gt;();
var registrationOptions2 = container[typeof(ILookupDataServiceType2)];
registrationOptions2.AsMultiInstances();
</code></pre>

<h3 id="property-injection">Property Injection<a class="headerlink" href="#property-injection" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h3>
<p>With Dependency attribute</p>
<pre><code class="cs">public class SubItem
{
    // properties, fields, ...
}

public class Item
{
    [Dependency] 
    // or with name 
    // [Dependency(Name = &quot;my key&quot;)]
    public SubItem MySubItem { get; set; }

    [Dependency] 
    public string MyString { get; set; }
}
</code></pre>

<pre><code class="cs">injector.RegisterInstance&lt;MySubItem&gt;(new SubItem());
injector.RegisterType&lt;Item&gt;().WithValueContainer(new ValueContainer { { &quot;myString&quot;, &quot;my value&quot; } });

var instance = injector.BuildUp&lt;Item&gt;();
</code></pre>

<p>Or AutoDiscovery</p>
<pre><code class="cs">var instance = injector.BuildUp&lt;Item&gt;();
</code></pre>

<p>With OnResolved (allows to handle circular references)</p>
<pre><code class="cs">public class CircularPropertyItem
{
    public CircularPropertyItem Item { get; set; } // circular reference

    // other properties
    public string MyString { get; set; }
    public SubItem MySubItem { get; set; }
}
</code></pre>

<pre><code class="cs">injector.RegisterType&lt;CircularPropertyItem&gt;().OnResolved((registration, instance) =&gt;
{
    var item = instance as CircularPropertyItem;
    item.Item = item; // circular reference

    // other properties
    item.MyString = &quot;My value&quot;;
    item.MySubItem = injector.GetInstance&lt;SubItem&gt;();
});

var result = injector.GetInstance&lt;CircularPropertyItem&gt;();
</code></pre>

<h2 id="getinstance">GetInstance<a class="headerlink" href="#getinstance" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h2>
<pre><code class="cs">var item = injector.GetInstance&lt;Item&gt;(); 
var service = injector.GetInstance&lt;IMyService&gt;();
// with key
var item2 = injector.GetInstance&lt;Item&gt;(&quot;my key&quot;);
</code></pre>

<p>Get new Instance (only for Types)</p>
<pre><code class="cs">var item = injector.GetNewInstance&lt;Item&gt;();
</code></pre>

<p>Get all instances of Type</p>
<pre><code class="cs">var instances = service.GetAllInstances&lt;Item&gt;();
</code></pre>

<h2 id="autodiscovery">AutoDiscovery<a class="headerlink" href="#autodiscovery" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h2>
<p>By default, the injector try to resolve automatically non registered types.</p>
<p>To change this behavior:</p>
<pre><code class="cs">injector.AutoDiscovery = false;
</code></pre>

<h2 id="nonpublicconstructors-and-nonpublicproperties">NonPublicConstructors and NonPublicProperties<a class="headerlink" href="#nonpublicconstructors-and-nonpublicproperties" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h2>
<p>By default, the injector find public and private constructors/ properties</p>
<p>To change this behavior:</p>
<pre><code class="cs">injector.NonPublicConstructors = false;
injector.NonPublicProperties = false;
</code></pre>

<h2 id="preferredconstructorattribute">PreferredConstructorAttribute<a class="headerlink" href="#preferredconstructorattribute" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h2>
<p>Example</p>
<pre><code class="cs">public class MyViewModel
{
    public MyViewModel()
    {

    }

    public MyViewModel(IRegionManager regionManager)
    {

    }

    [PreferredConstructor]
    public MyViewModel(IRegionManager regionManager, IMessenger messenger)
    {

    }
}
</code></pre>

<h2 id="delegatefactorytype">DelegateFactoryType<a class="headerlink" href="#delegatefactorytype" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h2>
<p>By default, the injector use the ExpressionDelegateFactoryType (create instances with expressions linq)</p>
<p>Change to ReflectionDelegateFactory (less performant)</p>
<pre><code class="cs">injector.DelegateFactoryType = DelegateFactoryType.Reflection;
</code></pre>

<h2 id="events">Events<a class="headerlink" href="#events" title="Permalink to this headline"><i class="fa fa-link" aria-hidden="true"></i></a></h2>
<ul>
<li>Registered</li>
<li>Resolved</li>
</ul>
<pre><code class="cs">injector.Registered += (s, e) =&gt; { };

injector.Resolved += (s, e) =&gt; {  };
</code></pre>


                    </div>
                </div>
                <footer>
                    <hr />
                    <div role="contentinfo">
MvvmLib Documentation. &copy;2019. <a href='https://github.com/romagny13/MvvmLib' target='_blank'>GitHub</a> | <a href='https://www.nuget.org/profiles/romagny13' target='_blank'>NuGet</a>.
                    </div>
                </footer>
            </div>
        </section>
    </div>
    <script src="js/jquery-2.1.1.min.js"></script>
    <script src="js/modernizr-2.8.3.min.js"></script>
    <script src="js/highlight.pack.js"></script>
    <script src="js/theme.js"></script>

</body>
</html>
